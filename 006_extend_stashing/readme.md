# Extending the stashing feature to new modes

| AEP number | 006                                                          |
|------------|--------------------------------------------------------------|
| Title      | Extending the stashing feature to new modes                  |
| Authors    | [Marnik Bercx](mailto:marnik.bercx@epfl.ch) (mbercx), [Francisco Ramirez](mailto:francisco.ramirez@epfl.ch) (ramirezfranciscof) |
| Champions  | [Marnik Bercx](mailto:marnik.bercx@epfl.ch) (mbercx), [Francisco Ramirez](mailto:francisco.ramirez@epfl.ch) (ramirezfranciscof) |
| Type       | S - Standard Track                                           |
| Created    | 22-Jan-2021                                                  |
| Status     | submitted                                                    |

** VERY MUCH A WORK IN PROGRESS **

## Background 

AiiDA already provides a mechanism to manage the data that is generated by running calculation jobs.
It allows the user to either retrieve files to the local file repository via the `retrieve_list`, or simply leave them on the remote machine.
The advantage of retrieving data is that it becomes part of the permanent provenance, because the files in the working directory on the remote compute resources are often stored on a scratch storage that will be cleaned regularly.
Since AiiDA merely maintains a “soft-link” to the path, the data would be lost.
However, there is an intermediate case where one does not want to retrieve the data, because it may be too heavy to transfer over the line or store permanently, but it should also not be lost.
The user may want to store the files on the same remote computer but on a different storage volume that is more permanent.

In [#2150](https://github.com/aiidateam/aiida-core/issues/2150) the functionality was added to the CalcJob class to allows users to specify which files should be copied after the calculation job has terminated.
In order to avoid naming conflicts with the AiiDA archive export format, the feature was referred to as "stashing".
In the current design, the user can stash certain files produced by a calculation job by specifying the details in the `stash` namespace in the options of the inputs:

```
options['stash'] = {
  'source_list': [
    	    'out/aiida.save/charge-density.dat',
    	    'out/aiida.save/data-file-schema.xml',
    	    'out/aiida.save/paw.txt',
	],
	'target_base': '/home/sph/.scratch/stash',
	‘mode’: StashMode.COPY.value,
}
```

In this example, the three output files listed in the `source_list` are copied to a sharded folder in the `target_base` directory.
The `mode` input is an `Enum` that allows the user to specify how the data should be stashed.
As the current implementation only supports copying the , the only option here is to use Mode.COPY.

## Proposed Enhancement 

The goal of this enhancement is to extend the stashing feature to other stashing modes via a script installed on the remote machine.

## Detailed Explanation 

The extension with more stashing modes will depend on the mode:

* Some modes, such as StashMode.TAR, can be implemented directly into `aiida-core`, and will not require a script on the remote machine.
* Others may not have a Python api and can need some customization from the user.

#### Configuration

Modes such as TAR, TARGZ (others?) where we implement the code in `aiida-core` for stashing and unstashing. This would require that the user only changes the `mode` value in options[‘stash’][‘mode’], otherwise the functionality for the stashing operation is exactly the same. Of course, this code would have to be executed on the remote computer, so maybe the user still has to first configure a location for the .py file that contains the code that does the stashing/unstashing.

A more generic REMOTE_SCRIPT mode which relies on a script that is installed on  the remote computer. The user here has to both set options[‘stash’][‘mode’] to `StashMode.REMOTE_SCRIPT` and specify which script to use. Currently, the idea is to place all possible scripts that can be used for stashing/unstashing on a computer inside one .py file on that computer, and configure the path to that script on the `Computer`. 

For the `StashMode.REMOTE_SCRIPT`, we also need to add more parameters to the stashing operation, since there can be multiple scripts inside the file that is configured on the computer.

options['stash'] = {
	'target_base': '/home/sph/.scratch/stash',
	'source_list': [
    	    'out/aiida.save/charge-density.dat',
    	    'out/aiida.save/data-file-schema.xml',
    	    'out/aiida.save/paw.txt',
	],
	‘mode’: Mode.COPY.value,
  'remote_parameters': {'': ''}  # Or 'stash_parameters'? -> Perhaps you would have different compression modes for the targz stashing opertion, for example.
}

StashMode.TAR:

'stash_parameters' will be passed to the `tarfile.open` command. Test this to see how it works exactly. 

Remote_params go in the attributes
Remote_params get written in the JSON that the script reads
Unstasher script accepts the exact same dictionary (possibly ignoring some parameters specific only to stashing like compression level)

#### Data types

Class Mode(Enum):

	COPY = ‘copy’
	TAR = ‘tar’
	TARGZ = ‘targz’
	REMOTE_SCRIPT = ‘remote_script’

For each stashing mode, we have a separate data type, all inheriting form the unstorable `RemoteStashData` class:

* COPY: `RemoteStashFolderData`
* TAR: `RemoteStashTarData`
* TARGZ: `RemoteStashTargzData`
* REMOTE_SCRIPT: `RemoteStashScriptData`

#### Stashing once the calculation is completed

#### Unstashing

For the COPY mode, we can use a simple calculation function to convert a `RemoteStashData` into a `RemoteFolderData`, since this is just changing the data type (i.e. both are essentially symbolic links to a remote location).
For other modes for which we provide the implementation (TAR, TARGZ, …), the calculation function is not ideal, since the unstashing operation might take some time. Here, we can extend the `TransferCalcJob` to allow it to perform unstashing operations.
For the `RemoteStashData`s that rely on a remote script, the unstashing operation must be defined in the .py file configured for that remote computer.

Parent folder input: Do we simply allow the `parent_folder` as an input of the calculation job, or do we expect the user to adapt their workflows so they use the `TransferCalcJob` to unstash the data they want to restart from?

Adapting the calculation job seems to be the way to go, since the concept of AiiDA is to build workflows from basic building blocks.
Having to adapt each workflow to deal with the unstashing seems tedious and inefficient.

This means that each calculation job needs to adapt their `parent_folder` input to also accept `RemoteStashData` as well as the `prepare_submission` script.
The engine will also need to be extended to be able to deal with the unstashing, e.g. through `calcinfo.remote_unstash_list` (Think about how we can actually do this properly)?

However, since stashing operations can take quite some time, they would be blocking the daemon worker.


#### General restrictions

The most simple model would impose already some restrictions. When these are lifted, the model and implementation would inherently become a lot more complicated. For now we assume that these limitations are not critical and are defined as follows:

Same computer: files or a subset of files of any single calculation can only be archived on the same computer. That is to say, whatever the archive method, it has to function within the same computer
Single location: files or a subset of files of any single calculation can only be archived to a single location. It will not be possible to archive multiple files in different locations with different methods
Single method: files or a subset of files of any single calculation can only be archived with a single method.

The most basic interface should allow to specify the following
The absolute base path of the storage location
The list of relative paths of produced files in the work directory that should be included in the archive

## Pros and Cons 

### Pros
* The public discussion of enhancement proposals lets the entire AiiDA community see what developments lie ahead
  and allows those interested to actively participate in shaping them
* AEPs provide basic guidance on how to "make a case" for an enhancement such that it can be seriously discussed
  before investing efforts in its implementation
* The corresponding pull requests provide a public record of the decision process in case questions arise later

### Cons
* Slightly increased overhead compared to an informal email trail or a Google document
